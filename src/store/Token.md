# 关于 Token 过期的问题

## access_token

获取需要授权的借口数据

## expires_in

access_token 过期时间  
为了安全，过期时间越短越好

## refresh_token

过期之后，刷新获取新的 access_token

### 刷新方法

#### 方法一：请求拦截器判断

在请求发起前拦截每个请求，判断 token 是否过期，若已经过期，则将请求挂起，先刷新 token 后再继续请求

- 优点：在请求前拦截，能节省请求，省流量
- 缺点：需要后端额外提供一个 token 过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败

#### 方法二：相应拦截器判断

在接口返回数据之后，查看状态码效验是否过期，如果过期，先刷新 token，再进行一次请求

- 有点：不需要额外的 token 过期时间字段，前端不判断是否过期
- 缺点：会小号多一次请求（流量）

# 关于 Token 过期的问题

## access_token

获取需要授权的借口数据

## expires_in

access_token 过期时间  
为了安全，过期时间越短越好

## refresh_token

过期之后，刷新获取新的 access_token

### 刷新方法

#### 方法一：请求拦截器判断

在请求发起前拦截每个请求，判断 token 是否过期，若已经过期，则将请求挂起，先刷新 token 后再继续请求

- 优点：在请求前拦截，能节省请求，省流量
- 缺点：需要后端额外提供一个 token 过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败

#### 方法二：相应拦截器判断

在接口返回数据之后，查看状态码效验是否过期，如果过期，先刷新 token，再进行一次请求

- 有点：不需要额外的 token 过期时间字段，前端不判断是否过期
- 缺点：会小号多一次请求（流量）

#### 总结

方法一和方法二优缺点是互补的，方法一有晓燕失败的风险（本地时间被篡改），方法二更简单粗暴，等知道服务器已经过期了再重试一次，只会消耗一个请求
